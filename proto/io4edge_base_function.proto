syntax = "proto3";

package io4edgeBaseFunction;
option go_package = "pkg/io4edge/basefunc";


message SerialNumber {
    uint64 hi = 1;
    uint64 lo = 2;
}

enum BaseFuncCommandId {
    IDENTIFY_HARDWARE = 0;
    IDENTIFY_FIRMWARE = 1;
    LOAD_FIRMWARE_CHUNK = 2;
    PROGRAM_HARDWARE_IDENTIFICATION = 3;
}


enum BaseFuncStatus {
    OK = 0;
    UNKNOWN_COMMAND = 1;
    PROGRAMMING_ERROR = 2;
    CHUNK_SEQ_ERROR = 3;
    NOT_COMPATIBLE = 4;
}

// Individual Commands and Responses

// LoadFirmware
// Client sends sequence of CmdLoadFirmwareChunk commands, with increasing
// chunk numbers. Clients defines chunk size.
// Server must acknowledge each chunk with Response.
// Last chunk has is_last_chunk set to True, so server knows that programming has finished
message CmdLoadFirmwareChunk {
    uint32 chunk_number = 1;
    bool is_last_chunk = 2;
    bytes data = 3;
}

message CmdProgramHardwareIdentification {
    string password = 1;
    string root_article = 2;
    uint32 major_version = 3;
    SerialNumber serial_number = 4;
}

message ResIdentifyHardware {
    string root_article = 1;
    uint32 major_version = 2;
    SerialNumber serial_number = 3;
}

message ResIdentifyFirmware {
    string name = 1;
    uint32 major_version = 2;
    uint32 minor_version = 3;
    uint32 patch_version = 4;
}

// The common messages
message BaseFuncCommand {
    BaseFuncCommandId id = 1;
    oneof data {
        CmdLoadFirmwareChunk load_firmware_chunk = 2;
        CmdProgramHardwareIdentification program_hardware_identification = 3;
    }
}

message BaseFuncResponse {
    BaseFuncCommandId id = 1;
    BaseFuncStatus status = 2;
    oneof data {
        ResIdentifyHardware identify_hardware = 3;
        ResIdentifyFirmware identify_firmware = 4;
    }
}
